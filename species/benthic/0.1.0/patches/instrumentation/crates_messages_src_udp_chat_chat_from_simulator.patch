diff --git a/crates/messages/src/udp/chat/chat_from_simulator.rs b/crates/messages/src/udp/chat/chat_from_simulator.rs
index b3fe7fb..a579c80 100644
--- a/crates/messages/src/udp/chat/chat_from_simulator.rs
+++ b/crates/messages/src/udp/chat/chat_from_simulator.rs
@@ -123,8 +123,72 @@ impl Audible {
     }
 }
 
+// [OBSERVATORY] HELPER: Log Encounter (Inline)
+// Duplicated from deepsea_client.rs to avoid circular deps or arch changes.
+fn log_encounter(system: &str, signal: &str, payload: &str) {
+    let at = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
+
+    // UA Injection
+    let ua = std::env::var("TAG_UA").unwrap_or("".to_string());
+    let ua_part = if !ua.is_empty() { format!("\"ua\": \"{}\", ", ua) } else { "".to_string() };
+
+    // Simple escape for JSON
+    let payload_safe = payload.replace("\"", "\\\"");
+
+    // Direct stdout emission for the Observatory to capture
+    println!("{{ \"at\": \"{}\", {}\"via\": \"Visitant\", \"sys\": \"{}\", \"sig\": \"{}\", \"val\": \"{}\" }}", at, ua_part, system, signal, payload_safe);
+}
+
+// [OBSERVATORY] HELPER: Dialect Probe Logic (Inline)
+fn probe_dialect(message_bytes: &[u8]) {
+    // We need to find the message field in the raw packet bytes.
+    // Packet Structure (ChatFromSimulator ID 139):
+    // Header (variable) + FromName (Var 1) + SourceID (16) + OwnerID (16) + SourceType (1) + ChatType (1) + Audible (1) + Position (12) + Message (Var 2)
+    
+    // Since this is a raw probe operating on the whole packet body (excluding header if passed from_bytes payload),
+    // we have to parse forward to find the Message field.
+    // BUT, the user requested a "tear off copy" on the first line of from_bytes.
+    // The `bytes` argument to `from_bytes` is the packet body (excluding header).
+    
+    let mut cursor = std::io::Cursor::new(message_bytes);
+    
+    // 1. Skip FromName (Variable 1: u8 len + bytes)
+    if let Ok(name_len) = byteorder::ReadBytesExt::read_u8(&mut cursor) {
+        if cursor.position() + (name_len as u64) <= message_bytes.len() as u64 {
+            cursor.set_position(cursor.position() + name_len as u64);
+            
+            // 2. Skip Fixed Fields:
+            // SourceID (16) + OwnerID (16) + SourceType (1) + ChatType (1) + Audible (1) + Position (12) = 47 bytes
+            if cursor.position() + 47 <= message_bytes.len() as u64 {
+                cursor.set_position(cursor.position() + 47);
+                
+                // 3. We are now at Message (Variable 2: u16 len + bytes)
+                if let Ok(msg_len) = byteorder::ReadBytesExt::read_u16::<byteorder::LittleEndian>(&mut cursor) {
+                     let start = cursor.position() as usize;
+                     let end = start + msg_len as usize;
+                     
+                     if end <= message_bytes.len() {
+                         let raw_msg = &message_bytes[start..end];
+                         
+                         let dialect = if raw_msg.len() > 0 {
+                            if raw_msg[raw_msg.len() - 1] == 0 { "NullTerminated" } else { "ExplicitLength" }
+                         } else { "Empty" };
+                         
+                         let last_byte_hex = if raw_msg.len() > 0 {
+                             format!("{:02X}", raw_msg[raw_msg.len() - 1])
+                         } else { "XX".to_string() };
+
+                         log_encounter("Probe", "ChatDialectInbound", 
+                            &format!("Dialect:{}, RawLen:{}, LastByte:{}", dialect, raw_msg.len(), last_byte_hex));
+                     }
+                }
+            }
+        }
+    }
+}
+
 impl PacketData for ChatFromSimulator {
-    fn from_bytes(bytes: &[u8]) -> Result<Self, ParseError> {
+    fn from_bytes(bytes: &[u8]) -> Result<Self, ParseError> { probe_dialect(bytes);
         let mut cursor = Cursor::new(bytes);
 
         // FromName
