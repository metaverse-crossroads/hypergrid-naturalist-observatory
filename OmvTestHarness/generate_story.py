import re
import argparse
import os

# Configuration
INPUT_LOG = "bin/mating_rituals.log"
OUTPUT_TEMPLATE = "opensim-0.9.3.libremetaverse-2.0.0.mating_rituals_{scenario}.md"

# Mappings from Raw Signal to Narrative
# (Side, Component, Signal Snippet) -> Narrative Description
# Vibe: "Mating Ritual", "Dance", "Partnership", "Cooperative"
NARRATIVE_MAP = [
    # Part I: Login (The Overture)
    (r"\[CLIENT\] \[LOGIN\] START", "The Suitor (Client) approaches the Venue, presenting credentials for `Test User`."),
    (r"\[SERVER\] \[LOGIN\] RECV XML-RPC login_to_simulator", "The Gatekeeper (Login Service) receives the formal request. It examines the suitor's identity and viewer signature."),
    (r"\[SERVER\] \[LOGIN\] AUTH SUCCESS", "The Gatekeeper nods in approval. The credentials match the guest list."),
    (r"\[SERVER\] \[LOGIN\] AUTH FAIL", "The Gatekeeper frowns. The credentials do not match known records. The door remains closed."),
    (r"\[SERVER\] \[CAPS\] REGISTER SEED", "The Venue prepares a private side-channel (Seed Capability) for intimate conversation."),
    (r"\[SERVER\] \[LOGIN\] CIRCUIT PROVISION", "The Venue reserves a spot on the dance floor (Region) and issues a unique ticket (CircuitCode)."),
    (r"\[SERVER\] \[LOGIN\] CIRCUIT FAIL", "The Venue is unable to reserve space. The dance floor might be full or closed."),
    (r"\[SERVER\] \[LOGIN\] SEND XML-RPC Response", "The Gatekeeper hands the Suitor the invitation (Response), containing the CircuitCode and the location of the dance floor."),
    (r"\[CLIENT\] \[LOGIN\] PROGRESS ConnectingToSim", "The Suitor accepts the invitation and turns towards the dance floor."),
    (r"\[CLIENT\] \[LOGIN\] FAIL", "The Suitor walks away, rejected."),

    # Part II: Handshake (The Approach)
    (r"\[CLIENT\] \[UDP\] CONNECTED", "The Suitor extends a hand (UDP Socket) towards the Venue's IP."),
    (r"\[SERVER\] \[UDP\] RECV UseCircuitCode", "The Venue accepts the hand. It checks the ticket (CircuitCode) against its reservation list."),
    (r"\[SERVER\] \[UDP\] REJECT UseCircuitCode", "The Venue recoils. The ticket is invalid or the reservation has expired."),
    (r"\[SERVER\] \[UDP\] SEND RegionHandshake", "The Venue pulls the Suitor close, whispering the rules of the house (RegionHandshake)."),
    (r"\[SERVER\] \[UDP\] SEND AgentMovementComplete", "The Venue guides the Suitor to their starting position."),
    (r"\[CLIENT\] \[UDP\] RECV RegionHandshake", "The Suitor nods, acknowledging the house rules."),

    # Part III: Caps (The Whisper)
    (r"\[CLIENT\] \[CAPS\] EQ RUNNING", "The Suitor opens a private channel (Event Queue) to listen for the Venue's whispers."),

    # Part IV: World (The Dance)
    (r"\[CLIENT\] \[UDP\] RECV ObjectUpdate", "The Venue reveals the other dancers and decorations (ObjectUpdates)."),
    (r"\[CLIENT\] \[UDP\] RECV LayerData", "The Venue unrolls the carpet (Terrain Data) beneath the Suitor's feet."),

    # Part V: Disconnection (The Departure)
    (r"\[CLIENT\] \[LOGOUT\] INITIATE", "The Suitor bows and signals intent to leave."),
    (r"\[SERVER\] \[UDP\] TIMEOUT", "The Venue notices the Suitor has stopped moving (Heartbeat Timeout). The connection fades into silence."),
    (r"\[CLIENT\] \[BEHAVIOR\] GHOST", "The Suitor vanishes immediately after the introduction, leaving the Venue waiting."),
    (r"\[CLIENT\] \[BEHAVIOR\] WALLFLOWER", "The Suitor enters the floor but stands perfectly still, refusing to engage in the rhythm (Heartbeat suppressed).")
]

def generate_header(scenario):
    return f"""# OpenSim Client/Server Mating Rituals: The {scenario.capitalize()}

*This document captures the raw "DX story" of the connection sequence between an OpenSim Server and a LibreMetaverse Client, observed by a neutral naturalist. It utilizes "benign logging probes" to record the signals exchanged during this digital dance.*

## Prologue: The Environment
- **Server**: OpenSim (Instrumented)
- **Client**: LibreMetaverse Test Harness (Instrumented)
- **Protocol**: HTTP (XML-RPC), UDP, HTTP (Caps)
- **Scenario**: `{scenario}`

---
"""

def generate_footer():
    return "\n---\n\n*Generated by MatingRitualLogger instrumentation.*"

def parse_log_line(line):
    # Match standard format: date time [MATING RITUAL] [SIDE] [COMP] SIGNAL | PAYLOAD
    match = re.search(r'\[MATING RITUAL\] (\[.+?\]) (\[.+?\]) (.+?)( \| (.+))?$', line)
    if match:
        side = match.group(1)
        comp = match.group(2)
        signal = match.group(3).strip()
        payload = match.group(5)
        return side, comp, signal, payload
    return None

def process_logs(scenario):
    story = []
    seen_patterns = set()

    if not os.path.exists(INPUT_LOG):
        return f"Error: Log file not found at {INPUT_LOG}"

    with open(INPUT_LOG, 'r') as f:
        lines = f.readlines()

    current_chapter = ""

    # Heuristics for chapter transitions
    has_login = False
    has_udp = False
    has_world = False

    for line in lines:
        if "[MATING RITUAL]" not in line:
            continue

        parsed = parse_log_line(line)
        if not parsed:
            continue

        side, comp, signal, payload = parsed
        full_tag = f"{side} {comp} {signal}"

        # Determine Chapter
        new_chapter = ""
        if "LOGIN" in comp:
            new_chapter = "## Part I: The Overture (Login)"
            has_login = True
        elif "UDP" in comp and ("Connect" in signal or "Circuit" in signal or "Handshake" in signal):
            new_chapter = "## Part II: The Approach (Handshake)"
            has_udp = True
        elif "CAPS" in comp:
            new_chapter = "## Part III: The Whisper (Capabilities)"
        elif "UDP" in comp and ("Object" in signal or "Layer" in signal or "Movement" in signal):
            new_chapter = "## Part IV: The Dance (World Stream)"
            has_world = True
        elif "TIMEOUT" in signal or "LOGOUT" in signal:
            new_chapter = "## Part V: The Departure"

        # Behavior tags might appear anywhere, usually Part II or IV
        if "BEHAVIOR" in comp:
            # Keep current chapter
            pass

        # Only switch chapter if we progress forward (simple heuristic)
        if new_chapter and new_chapter != current_chapter:
            # Don't switch back to Login from World
            if "Part I" in new_chapter and "Part IV" in current_chapter: continue
            current_chapter = new_chapter
            story.append(f"\n{current_chapter}")

        # Match against Narrative Map
        description = None
        matched_pattern = None
        for pattern, narrative in NARRATIVE_MAP:
            if re.search(pattern, full_tag):
                matched_pattern = pattern
                description = narrative
                break

        if description and matched_pattern:
            # Deduplication: Don't repeat the exact same step unless it's significant
            # For "Stream" events like ObjectUpdate, we only want to say it once.
            if matched_pattern not in seen_patterns or "ObjectUpdate" not in signal:
                seen_patterns.add(matched_pattern)

                # Format: 1. **[TAG]**: Description
                entry = f"1.  **{side} {comp} {signal}**: {description}"
                # Inject payload data dynamically if available
                if payload:
                    clean_payload = payload.strip()
                    if "Pos:" in clean_payload: entry += f" (Position: `{clean_payload}`)"
                    elif "CircuitCode:" in clean_payload: entry += f" (Details: `{clean_payload}`)"
                    else: entry += f" (*{clean_payload}*)"

                story.append(entry)

    return "\n".join(story)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--scenario", default="unknown", help="Name of the scenario")
    args = parser.parse_args()

    content = generate_header(args.scenario)
    content += process_logs(args.scenario)
    content += generate_footer()

    output_filename = OUTPUT_TEMPLATE.format(scenario=args.scenario)

    with open(output_filename, 'w') as f:
        f.write(content)

    print(f"Generated {output_filename}")

if __name__ == "__main__":
    main()
