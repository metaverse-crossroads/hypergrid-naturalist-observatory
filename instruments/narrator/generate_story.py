import re
import argparse
import os

# Configuration
INPUT_LOG = "vivarium/encounter.log"
OUTPUT_TEMPLATE = "opensim-0.9.3.libremetaverse-2.0.0.encounter_{scenario}.md"

# Mappings from Raw Signal to Narrative
# (Side, Component, Signal Snippet) -> Narrative Description
# Vibe: "Naturalist", "Observatory", "Visitant", "Range"
NARRATIVE_MAP = [
    # Part I: Login (The Introduction)
    (r"\[CLIENT\] \[LOGIN\] START", "The Visitant (Client) approaches the Range, presenting credentials for `Test User`."),
    (r"\[SERVER\] \[LOGIN\] RECV XML-RPC login_to_simulator", "The Access Control (Login Service) receives the formal request. It examines the Visitant's identity and viewer signature."),
    (r"\[SERVER\] \[LOGIN\] AUTH SUCCESS", "The Access Control nods in approval. The credentials match the guest list."),
    (r"\[SERVER\] \[LOGIN\] AUTH FAIL", "The Access Control frowns. The credentials do not match known records. The door remains closed."),
    (r"\[SERVER\] \[CAPS\] REGISTER SEED", "The Range prepares a private side-channel (Seed Capability) for intimate conversation."),
    (r"\[SERVER\] \[LOGIN\] CIRCUIT PROVISION", "The Range reserves a spot in the Territory (Region) and issues a unique ticket (CircuitCode)."),
    (r"\[SERVER\] \[LOGIN\] CIRCUIT FAIL", "The Range is unable to reserve space. The Territory might be full or closed."),
    (r"\[SERVER\] \[LOGIN\] SEND XML-RPC Response", "The Access Control hands the Visitant the invitation (Response), containing the CircuitCode and the location of the Territory."),
    (r"\[CLIENT\] \[LOGIN\] PROGRESS ConnectingToSim", "The Visitant accepts the invitation and turns towards the Territory."),
    (r"\[CLIENT\] \[LOGIN\] FAIL", "The Visitant walks away, rejected."),

    # Part II: Handshake (The Approach)
    (r"\[CLIENT\] \[UDP\] CONNECTED", "The Visitant extends a hand (UDP Socket) towards the Range's IP."),
    (r"\[SERVER\] \[UDP\] RECV UseCircuitCode", "The Range accepts the hand. It checks the ticket (CircuitCode) against its reservation list."),
    (r"\[SERVER\] \[UDP\] REJECT UseCircuitCode", "The Range recoils. The ticket is invalid or the reservation has expired."),
    (r"\[SERVER\] \[UDP\] SEND RegionHandshake", "The Range pulls the Visitant close, whispering the rules of the house (RegionHandshake)."),
    (r"\[SERVER\] \[UDP\] SEND AgentMovementComplete", "The Range guides the Visitant to their starting position."),
    (r"\[CLIENT\] \[UDP\] RECV RegionHandshake", "The Visitant nods, acknowledging the house rules."),

    # Part III: Caps (The Signal)
    (r"\[CLIENT\] \[CAPS\] EQ RUNNING", "The Visitant opens a private channel (Event Queue) to listen for the Range's whispers."),

    # Part IV: World (The Interaction)
    (r"\[CLIENT\] \[UDP\] RECV ObjectUpdate", "The Range reveals the other occupants and decorations (ObjectUpdates)."),
    (r"\[CLIENT\] \[UDP\] RECV LayerData", "The Territory reveals its terrain (Terrain Data) beneath the Visitant's feet."),

    # Part V: Disconnection (The Departure)
    (r"\[CLIENT\] \[LOGOUT\] INITIATE", "The Visitant bows and signals intent to leave."),
    (r"\[SERVER\] \[UDP\] TIMEOUT", "The Range notices the Visitant has stopped moving (Heartbeat Timeout). The connection fades into silence."),
    (r"\[CLIENT\] \[BEHAVIOR\] GHOST", "The Visitant vanishes immediately after the introduction, leaving the Range waiting."),
    (r"\[CLIENT\] \[BEHAVIOR\] WALLFLOWER", "The Visitant enters the Territory but stands perfectly still, refusing to engage in the rhythm (Heartbeat suppressed).")
]

def generate_header(scenario):
    return f"""# OpenSim Client/Server Encounters: The {scenario.capitalize()}

*This document captures the raw "DX story" of the connection sequence between an OpenSim Server and a LibreMetaverse Client, observed by a neutral naturalist. It utilizes "benign logging probes" to record the signals exchanged during this digital interaction.*

## Prologue: The Environment
- **Server**: OpenSim (Instrumented)
- **Client**: Mimic (Instrumented)
- **Protocol**: HTTP (XML-RPC), UDP, HTTP (Caps)
- **Scenario**: `{scenario}`

---
"""

def generate_footer():
    return "\n---\n\n*Generated by EncounterLogger instrumentation.*"

def parse_log_line(line):
    # Match standard format: date time [ENCOUNTER] [SIDE] [COMP] SIGNAL | PAYLOAD
    match = re.search(r'\[ENCOUNTER\] (\[.+?\]) (\[.+?\]) (.+?)( \| (.+))?$', line)
    if match:
        side = match.group(1)
        comp = match.group(2)
        signal = match.group(3).strip()
        payload = match.group(5)
        return side, comp, signal, payload
    return None

def process_logs(scenario):
    story = []
    seen_patterns = set()

    if not os.path.exists(INPUT_LOG):
        return f"Error: Log file not found at {INPUT_LOG}"

    with open(INPUT_LOG, 'r') as f:
        lines = f.readlines()

    current_chapter = ""

    # Heuristics for chapter transitions
    has_login = False
    has_udp = False
    has_world = False

    for line in lines:
        if "[ENCOUNTER]" not in line:
            continue

        parsed = parse_log_line(line)
        if not parsed:
            continue

        side, comp, signal, payload = parsed
        full_tag = f"{side} {comp} {signal}"

        # Determine Chapter
        new_chapter = ""
        if "LOGIN" in comp:
            new_chapter = "## Part I: The Introduction (Login)"
            has_login = True
        elif "UDP" in comp and ("Connect" in signal or "Circuit" in signal or "Handshake" in signal):
            new_chapter = "## Part II: The Approach (Handshake)"
            has_udp = True
        elif "CAPS" in comp:
            new_chapter = "## Part III: The Signal (Capabilities)"
        elif "UDP" in comp and ("Object" in signal or "Layer" in signal or "Movement" in signal):
            new_chapter = "## Part IV: The Interaction (World Stream)"
            has_world = True
        elif "TIMEOUT" in signal or "LOGOUT" in signal:
            new_chapter = "## Part V: The Departure"

        # Behavior tags might appear anywhere, usually Part II or IV
        if "BEHAVIOR" in comp:
            # Keep current chapter
            pass

        # Only switch chapter if we progress forward (simple heuristic)
        if new_chapter and new_chapter != current_chapter:
            # Don't switch back to Login from World
            if "Part I" in new_chapter and "Part IV" in current_chapter: continue
            current_chapter = new_chapter
            story.append(f"\n{current_chapter}")

        # Match against Narrative Map
        description = None
        matched_pattern = None
        for pattern, narrative in NARRATIVE_MAP:
            if re.search(pattern, full_tag):
                matched_pattern = pattern
                description = narrative
                break

        if description and matched_pattern:
            # Deduplication: Don't repeat the exact same step unless it's significant
            # For "Stream" events like ObjectUpdate, we only want to say it once.
            if matched_pattern not in seen_patterns or "ObjectUpdate" not in signal:
                seen_patterns.add(matched_pattern)

                # Format: 1. **[TAG]**: Description
                entry = f"1.  **{side} {comp} {signal}**: {description}"
                # Inject payload data dynamically if available
                if payload:
                    clean_payload = payload.strip()
                    if "Pos:" in clean_payload: entry += f" (Position: `{clean_payload}`)"
                    elif "CircuitCode:" in clean_payload: entry += f" (Details: `{clean_payload}`)"
                    else: entry += f" (*{clean_payload}*)"

                story.append(entry)

    return "\n".join(story)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--scenario", default="unknown", help="Name of the scenario")
    args = parser.parse_args()

    content = generate_header(args.scenario)
    content += process_logs(args.scenario)
    content += generate_footer()

    output_filename = OUTPUT_TEMPLATE.format(scenario=args.scenario)

    with open(output_filename, 'w') as f:
        f.write(content)

    print(f"Generated {output_filename}")

if __name__ == "__main__":
    main()
